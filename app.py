# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IyddjZ7-trhHo_nsGtG1afXjHdyl6H5J
"""

import streamlit as st
import pandas as pd
import numpy as np
import folium
from folium.plugins import HeatMap
from streamlit_folium import folium_static
import seaborn as sns
import matplotlib.pyplot as plt
from io import BytesIO
import plotly.express as px

# -------------------------------
# Page Settings
# -------------------------------
st.set_page_config(page_title="Disaster Risk Management Dashboard", layout="wide")

# -------------------------------
# Load Azure Blob Data
# -------------------------------
@st.cache_data
def load_data():
    azure_blob_url = "https://uofrmlstudent1972267660.blob.core.windows.net/azureml-blobstore-c1ea77a6-69dd-40f4-b128-0361949bd439/azureml/e3e792dd-fde9-4ec6-a00d-45a7c43c8e7f/powerbi_output?sp=racw&st=2025-08-06T22:30:34Z&se=2025-08-07T06:45:34Z&sv=2024-11-04&sr=b&sig=EsPkGcLVV8PiL7l8r3gYFoURMzgVqZw38dHoQvIIDhs%3D"
    df = pd.read_csv(azure_blob_url)
    df['popup_info'] = df['disaster'] + ' (' + df['disaster_type'] + ', ' + df['country'] + ')'
    return df

df = load_data()

# -------------------------------
# Data Preprocessing
# -------------------------------
df['normalized_pop_density'] = (df['population_density'] - df['population_density'].min()) / \
                                (df['population_density'].max() - df['population_density'].min())

def density_category(x):
    if x > 0.9969:
        return 'High'
    elif x > 0.9967:
        return 'Medium'
    else:
        return 'Low'
def damage_category(x):
    if x > 0.66:
        return 'Destroyed'
    elif x > 0.33:
        return 'Major'
    elif x > 0:
        return 'Minor'
    else:
        return 'None'

df['pop_density_cat'] = df['population_density'].apply(density_category)
df['damage_cat'] = df['damage_level'].apply(damage_category)

# Risk Matrix Logic
risk_matrix = {
    ('High', 'Destroyed'): 'Critical', ('High', 'Major'): 'High',
    ('High', 'Minor'): 'Medium', ('High', 'None'): 'Low',
    ('Medium', 'Destroyed'): 'High', ('Medium', 'Major'): 'Medium',
    ('Medium', 'Minor'): 'Low', ('Medium', 'None'): 'Low',
    ('Low', 'Destroyed'): 'Medium', ('Low', 'Major'): 'Low',
    ('Low', 'Minor'): 'Low', ('Low', 'None'): 'Low'
}
df['risk_prediction'] = df.apply(lambda row: risk_matrix.get((row['pop_density_cat'], row['damage_cat']), 'Low'), axis=1)

# -------------------------------
# Sidebar Navigation + Filters
# -------------------------------
tab = st.sidebar.radio("üìä Select Dashboard View", ["Damage & Population Map", "Risk Matrix", "Weather Correlation"])
st.sidebar.markdown("""
**‚ÑπÔ∏è Filter Options**
Use these to drill down into specific disasters or regions.
""")
selected_disaster = st.sidebar.multiselect("Filter by Disaster Type", options=sorted(df['disaster_type'].unique()), default=sorted(df['disaster_type'].unique()))
selected_country = st.sidebar.multiselect("Filter by Country", options=sorted(df['country'].unique()), default=sorted(df['country'].unique()))

filtered_df = df[df['disaster_type'].isin(selected_disaster) & df['country'].isin(selected_country)]

# -------------------------------
# 1Ô∏è‚É£ Damage & Population Map
# -------------------------------
if tab == "Damage & Population Map":
    st.title("üåç Damage and Population Risk Map")
    st.markdown("""
    This map visualizes the geographic locations of disasters with two layers:
    - üî¥ **Damage Layer**: Shows the severity of damage using color-coded markers.
    - üü¢ **Population Density Heatmap**: Displays population exposure intensity.

    Use the filters on the sidebar to focus on specific disaster types or countries.
    """)

    m = folium.Map(location=[20, 0], zoom_start=2, tiles='cartodbpositron')

    # Layer 1: Damage
    damage_layer = folium.FeatureGroup(name='Damage Overlay')
    def get_color(d):
        return 'darkred' if d > 0.66 else 'orange' if d > 0.33 else 'yellow' if d > 0 else 'green'

    for _, row in filtered_df.iterrows():
        folium.CircleMarker(
            location=[row['lat'], row['lon']],
            radius=6,
            color=get_color(row['damage_level']),
            fill=True,
            fill_opacity=0.7,
            popup=row['popup_info']
        ).add_to(damage_layer)
    damage_layer.add_to(m)

    # Layer 2: Population Density
    pop_layer = folium.FeatureGroup(name='Population Density Heatmap')
    heat_data = [[row['lat'], row['lon'], row['normalized_pop_density']] for _, row in filtered_df.iterrows()]
    HeatMap(heat_data, radius=12, blur=15).add_to(pop_layer)
    pop_layer.add_to(m)

    folium.LayerControl(collapsed=False).add_to(m)
    folium_static(m, width=1200, height=700)

# -------------------------------
# 2Ô∏è‚É£ Risk Prediction Matrix
# -------------------------------
elif tab == "Risk Matrix":
    st.title("üìà Risk Prediction Matrix")
    st.markdown("""
    The matrix below shows the predicted risk based on population density and the level of damage:

    | Population Density | Destroyed | Major | Minor | None |
    |--------------------|-----------|-------|-------|------|
    | **High**           | Critical  | High  | Medium| Low  |
    | **Medium**         | High      | Medium| Low   | Low  |
    | **Low**            | Medium    | Low   | Low   | Low  |

    The matrix is computed from filtered data below using actual event data.
    """)

    matrix_order = ['High', 'Medium', 'Low']
    damage_order = ['Destroyed', 'Major', 'Minor', 'None']
    pivot = pd.crosstab(filtered_df['pop_density_cat'], filtered_df['damage_cat'])
    pivot = pivot.reindex(index=matrix_order, columns=damage_order)
    pivot = pivot.fillna(0).astype(int)

    fig, ax = plt.subplots(figsize=(8, 5))
    sns.heatmap(pivot, annot=True, fmt='d', cmap='Reds', ax=ax)
    ax.set_title("Population Density vs. Damage Level")
    st.pyplot(fig)

# -------------------------------
# 3Ô∏è‚É£ Weather Correlation
# -------------------------------
elif tab == "Weather Correlation":
    st.title("üå™Ô∏è Weather Correlation with Destruction")
    st.markdown("""
    This section visualizes how weather parameters (e.g., wind speed) correlate with disaster severity.

    - **X-axis**: Simulated wind speed (random data as placeholder).
    - **Y-axis**: Damage level (from data).
    - **Color**: Disaster type.
    """)

    np.random.seed(0)
    filtered_df['wind_speed'] = np.random.normal(100, 20, len(filtered_df))

    fig = px.scatter(filtered_df,
        x='wind_speed', y='damage_level',
        color='disaster_type',
        hover_data=['disaster', 'country', 'predicted_risk_level'],
        title="Wind Speed vs. Damage Level"
    )
    st.plotly_chart(fig, use_container_width=True)